sleep方法让线程挂起,CPU将在sleep的时间内不为该线程分配时间片

实际上，在系统内部，是通过SuspendThread和ResumeThread这两个API函数来实现线程的挂起/恢复。Windows内部维护一个挂起计数器，每执行一次SuspendThread，计数器加一，每执行一次ResumeThread，计数器减一。若计数器值大于0，则系统不为此线程分配时间片，即线程实际上不能运行，但其数据仍驻留在内存中，可以被访问，其他线程也可以修改它的状态，或者用ResumeThread来让他恢复运行。

sleep实际上是对这两个API的封装。

sleep 为何是静态的?
sleep设为静态的,这样它就只能挂起当前线程,如果设为实例方法,那么某个线程可以挂起其它线程(比如在 t1的 方法内部调用 t2.sleep,结果是在t1的方法内把t2给sleep了,如果设为sleep,那么t1 的方法内调用sleep只能挂起自己的线程),这样会带来一些问题,比如死锁
