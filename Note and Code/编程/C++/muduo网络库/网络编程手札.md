### TCP 编程要解决的问题
对于网络编程, 不论是socket,epoll 还是 poll,它们都是用户态函数, 互联网开发者在极大多数情况只是在用户态编程,因此我们的核心任务在于如何处理这些系统调用函数的特性
首先我们来看 socket 的特性,从读的角度来看,写类似.对于 recv/read, 若为阻塞 socket,则:
* 若无数据,阻塞等待
* 若有数据,则 read/recv,调用一次read 后会返回(返回>0,表示读到的字节数,还没读完,=0,表示这次read读完了),read不会阻塞,但调用一次不保证一口气读完了,那么则需循环 read,直到 read 完
对于非阻塞 socket
* 若无数据,直接返回
* 若有数据,规则和阻塞的read是相同的

从上面可以看见用户需要面对的问题
1. buffer 要非配多大? buffer 分配小了, read 不够会导致重分配的开销
2. 如果是非阻塞的,我们应该何时再去查看IO是否可读,但又不能把大量时间用于等待 IO,既保证有大量的时间都是在处理业务逻辑,又保证 IO 到来时被及时处理. 
一次read不完的情况加大了问题的复杂性,对于某个文件描述符,我们没有read到完整的包,就必须暂时切出去处理,等到业务逻辑到来时又切回来.
3. 理想的状况是,在请求量很大的情况下不会耗时在 IO 阻塞上,连花时间做无效的 IO 轮询都不要,只是在有IO的时候才切到IO处理,没有IO到来的时候我们就进行业务逻辑.这里的 IO 不单是在 TCP 连接的时候产生,还包括数据库连接,读写数据库等产生的 IO

问题的关键在于,我们要如何才能做到如此随心所欲地切换

#### 为什么需要协程
多线程可以避免IO的阻塞时间,却带来了线程创建和销毁的开销,没有协程的情况下,在一个进程中我们难以做到随心所欲地切换 IO, epoll 可以使我们在单进程中处理多个TCP连接而不会阻塞,但是对于每个客户端请求,假设我们还要做有IO的业务逻辑处理,比如IO逻辑处理中还需要读写mysql,读写redis等,当在这些IO操作中阻塞时,我们又该如何在阻塞这段时间切换出去,又该如何得知何时切换回来继续往下处理?
IO 阻塞时就切换出去,IO 可用时又可切换回来,协程可以帮助我们支持这样的编程方式
### TCP 编程经典解决办法
Non-blocking IO + IO 多路复用
实现方式 One loop per thread +  thread pool

## 多线程编程
基本数据类型,如 int,bool也不一定是线程安全的,一个线程给 int 64位 赋值,可能会分成两个32位操作的指令,另一个线程可能读到的是只写完 32 位时的值

### 线程同步
并发编程两种模型: message passing, shared memory. 多机多进程间通信只能用 message passing
线程同步四原则:
1. 减少共享对象,多线程带来的问题往往是数据共享导致
2. 使用高级并发编程构建,如 TaskQueue, Producer-COnsumer Queue, CountDownLatch等
3. 对于开发者,避免造轮子,底层同步原语尽量避免,只用非递归互斥器和条件变量,慎用读写锁,不用信号量

### mutex
作用临界区(C++中`{}`内就是一个临界区)内只有一个线程
使用 RALL
只使用非递归锁(特点,内外层加锁,如函数递归调用会死锁,如函数A加锁,函数A调用函数B,函数B加锁)
* 优点:问题容易定位: 借助如gdb 这样的工具,把各个线程的调用栈打印出来
* 缺点: 编程会困难复杂一些

不使用递归锁(可重入锁)
特点:如果加锁操作不满足内外层关系,则可保证临界区只有一个线程在占用,另一个被阻塞, 但如果加锁操作是内外层关系时,可重复加锁,不会死锁,如函数A加锁,函数A调用函数B,函数B加锁,不死锁,这也往往会导致问题(经典例子,外层遍历 vector, 内层在修改vector,则内层执行完返回外层可能导致迭代失效)

### 条件变量
条件变量与mutex不可互相替代,条件变量用于让一个线程进入等待状态(wait)直到另一个线程唤醒它(notify),所谓条件即要有一个或多个线程等待某个bool变量,最经典的场景是生产者消费者模型,生产者在产品队列满时必须wait,等消费者notify,消费者必须在产品队列空时wait,等生产者notify
条件变量的用法:
* 必须与 mutex 配合,bool变量的读写需要受 mutex 保护,如果没有保护,那么一个生产者生产了一个产品,可能会有多个消费者同时发现产品队列不为空,然后都进行消费
* 在mutex上锁时才能调用 wait和 notify,这是为了确保只有拿到锁的线程才有权力去通知其它线程
* 把判断 bool 条件放在while 循环里,原因是 spurious wakeup(虚假唤醒,表现为即使没有线程broadcast 或 signal 条件变量,wait 有可能偶尔返回)
```cpp
Mutex Lock(_mutex);
while(!queue.empty()) {
    wait(); //如果发生spurious wakeup, wait 返回,使用 while 使得还在循环里,继续wait,使用if则不能
}
```
