   执行业务代码的服务器 和 数据库服务器 有时往往不是同一台机器,它们的距离甚至间隔很远,如果我们把sql语句存
储在业务代码服务器中,即在业务端用ORM 生成sql语句,然后传送到数据库服务器中执行,那么我们就要考虑网络延迟的
代价,数据库从一台机器发送信号到另一台机器所需要的时间.
    数据库操作是需要加锁的,假设我们一个有一个数据库操作,需要先后执行insert,update,commit,如果这三个sql
语句都在客户端生成,那么它不得不先后分别发送到数据库中(因为要保证顺序, 因此先发送insert,等insert发送成功
并被执行,返回执行成功的消息,才能法update),这样就有两个网络延迟,除了网络延迟,当执行insert时要加行锁,
其它数据库操作不得不等这个操作commit后才能继续操作,这样才能保证事务的原子性.
    此外如果用java代码执行数据库操作,那么这个mysql操作过程结束后还有GC(垃圾回收)的时间.
    网络延迟,GC,锁 ,这些都是降低数据库并发性的原因.其中锁和网络延迟是紧密相关的,因为完成一个mysql
操作过程如果因为网络延迟需要花很长时间,那么这个锁也将持续很长时间.
    为了解决网络延迟带来的问题,我们可以考虑把sql语句存放到数据库中,比如将 insert,update,commit 三个
操作写成一个mysql 的过程(procedure),业务服务器只需要发送参数去调用数据的这个过程即可,而procedure只要
返回操作的结果(是否执行成功,是否有异常)给服务器即可,这样就相当于只要考虑发送参数给数据库的网络延迟,而不是
每条sql语句执行都需要一个网络延迟.(数据commit后的结果返回给业务服务器也需要网络延迟,但那个时候行锁已经
解除了)
    事实上,mysql本身对于sql语句操作同一行时能扛住的并发量是很高的,因此将sql语句存放在服务器中执行效率很
高. 这样做当然也有缺点,比如需要自己手写sql,因此对于特别需要高并发的数据操作我们才为其特别编写sql语句并
放在服务器调用.而对于没有特别并发要求的数据操作只需要在业务服务器用java代码实现即可.
