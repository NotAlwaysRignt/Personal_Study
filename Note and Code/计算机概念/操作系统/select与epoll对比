1.内核态怎么判断I/O流可读可写?
内核针对读缓冲区和写缓冲区来判断是否可读可写,这个动作与select和epoll无关,由内核完成


2.用户态怎么将文件句柄传递到内核态？
对于select:
select创建3个文件描述符集，并将这些文件描述符拷贝到内核中，这里限制了文件句柄的最大的数量为1024（注意是全部传入,第一次拷贝)


对于epoll:
首先执行epoll_create在内核开辟专属于epoll的高速cache区，并在该缓冲区建立红黑树和就绪链表(就是一个链表结构)，用户态传入的文件句柄将被放到红黑树中（第一次拷贝）。(这是epoll与select本质不同之处,在内核cache里创建了两个数据结构,虽然会占用一定存储空间,但将带来效率的质变)  


epoll 注册回调函数的本质:
异步是否能实现,关键不是什么epoll,epoll它只是接口罢了,我们之所以能够异步,是设备能够支持异步.设备不可用时CPU不阻塞在那里等待设备可用,而是休眠进程去做其它事情,当设备可用时,设备会向 CPU 发送中断信号, CPU在中断程序中唤醒相应的进程继续执行,这才是异步的本质.在这里,注册的回调函数就是那个被唤醒的线程  
(为什么要红黑树?个人理解,未验证:因为即使知道了是哪个文件描述符有事件到来,我们还需要知道与这个文件描述符更多的相关信息,比如这个文件描述符的事件类型等,这些事件类型就存放在红黑树的节点中,因此我们还是需要用已知的文件描述符在红黑树中找到相关节点)  


3.内核怎么通知监控者有I/O流可读可写？
对于select: 
内核在检测到文件句柄可读/可写时就产生中断通知监控者select，select被内核触发之后，就返回可读可写的文件句柄的总数(此时只是知道数量,并不知道具体哪个fd)


对于epoll:
epoll_ctl执行add动作时除了将文件句柄放到红黑树上之外，还向内核中断处理程序注册了该文件句柄的回调函数,告诉内核，如果这个文件句柄(文件描述符)的中断到了，就把它放到就绪链表里(能够快速找到文件句柄的核心所在,至于实现是非常底层的知识了).
于是内核在检测到某句柄可读可写时则调用该回调函数，回调函数将文件描述符放到就绪链表(复杂度 O(1) )。


4.监控者如何找到可读可写的I/O流并传递给用户态应用程序？
对于select:
select会将之前传递给内核的文件句柄再次从内核传到用户态（第2次拷贝），select返回给用户态的只是可读可写的文件句柄总数，再使用FD_ISSET宏函数来检测哪些文件I/O可读可写（for循环遍历,时间复杂度为O(n),因此当文件描述符很多时效率会下降)

对于epoll:
epoll_wait 函数 监控在内核cache里创建的就绪链表，如果就绪链表有文件句柄，则表示该文件句柄可读可写，并将它返回到用户态（少量的拷贝）,这样就不用像select一样要将所有文件描述符都返回然后逐个遍历了



5.继续循环时监控者怎样重复上述步骤？
对于select:
select对于事件的监控是建立在内核的修改之上的，也就是说经过一次监控之后，内核会修改位，因此再次监控时需要再次从用户态向内核态进行拷贝（第N次拷贝）

对于epoll:
由于内核不修改文件句柄的位，因此只需要在第一次传入就可以重复监控，直到使用epoll_ctl删除(就是删除红黑树上注册的fd)，否则不需要重新传入文件描述符，因此无多次拷贝。



6.epoll一定优于select?
在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调
