先上自己的结论:异步和同步必须在确定的层次讨论,否则是没有意义的  
以python tornado框架为例,python torrnado作为应用层的网络框架,它是异步的  
但它的底层实现借助了epoll,在内核态,epoll是同步IO,因为它要监听所有的socket,一旦有socket的文件描述符被添加到消息队列就要通知用户.  
epoll往下,CPU和网卡交互的过程是一个异步过程,CPU将请求发送给网卡,然后往下运行,网卡接收数据完毕后向CPU发送中断,CPU再从终端中处理请求  
而网络通信中,以太网是个同步时序逻辑，随信号传输时钟，必须两边设备同时就绪了才能开始传输数据，这又是同步的


阻塞和非阻塞,更多是在操作系统层次对某一个(注意是一个)进程或线程的描述,一个线程在调用 socket.accept() 时候会阻塞,但我们通过开启多线程去处理这个阻塞,就可以使当前的线程变为非阻塞,同样,借助操作系统提供的异步功能,我们一样可以实现非阻塞.(这里也体现了多线程和非阻塞的区别,多线程是实现非阻塞的一种手段)

但底层硬件在与CPU通信时往往是异步的(硬件在数据获取完毕后发送中断通知CPU),但操作系统一样可以向用户提供一个阻塞的接口,即用户调用这个接口时阻塞,但在底层硬件交互中这就是个异步的过程,因为这样编程逻辑更加简单.当然操作系统也可以选择向用户提供一个非阻塞的接口.这个时候用户使用这个接口就不会造成线程的阻塞了.


作者：灵剑
链接：https://www.zhihu.com/question/19732473/answer/117012135
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

一个网络包从应用程序A发到另一台电脑上的应用程序B，需要经历：
1. 从A的业务代码到A的软件框架  
2. 从A的软件框架到计算机的操作系统内核  
3. 从A所在计算机的内核到网卡
4. 从网卡经过网线发到交换机等设备，层层转发，到达B所在计算机的网卡
5. 从B所在计算机的网卡到B所在计算机的内核
6. 从B所在计算机的内核到B的程序的用户空间
7. 从B的软件框架到B的业务代码
 
 
首先1和7，这取决于软件框架的设计，如果软件框架可以beginXXX，然后立即返回，这就是一种异步调用，再比如javascript当中的异步HTTP调用，传入参数时提供一个回调函数，回调函数在完成时调用，再比如协程模型，调用接口后马上切换到其他协程继续执行，在完成时由框架切换回到协程中，这都是典型的异步接口设计


2和6，其实都需要调用方自己把数据在内核和用户空间里搬来搬去，其实都是同步接口，除非是IOCP这样的专门的异步传输接口，所以这一级其实是同步的，阻塞与非阻塞的区别其实是影响调用接口的结果（在特定条件下是否提前返回结果），而不是调用方式

3和5，内核一般通过缓冲区，使用DMA(直接内存访问)来传输数据，所以这一步又是异步的。

4，以太网是个同步时序逻辑，随信号传输时钟，必须两边设备同时就绪了才能开始传输数据，这又是同步的


**上面作者主要讲了同步异步的区别,下面来具体讲讲阻塞和非阻塞区别,参考另一位知乎用户**
作者：萧萧
链接：https://www.zhihu.com/question/19732473/answer/241673170
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执!行顺序和编写顺序是一致的）。

但同样， 现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。

非阻塞I/O 系统调用( nonblocking system call )的另一个替代品是 异步I/O系统调用 （asychronous system call）。 与非阻塞 I/O 系统调用类似，asychronous system call 也是会立即返回， 不会等待 I/O 操作的完成， 应用程序可以继续执行其他的操作， 等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。此处， 非阻塞I/O 系统调用( nonblocking system call ) 和 异步I/O系统调用 （asychronous system call）的区别是：一个非阻塞I/O 系统调用 read() 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。而异步I/O系统调用 read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。




