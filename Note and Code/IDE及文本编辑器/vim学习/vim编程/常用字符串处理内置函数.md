参考文章: https://blog.csdn.net/lihaicg/article/details/8364349  
### line ("expr")

The result is a Number , which is the line number of the file position given 
with expr .

The accepted positions are: 
. the cursor position 
$ the last line in the current buffer

x position of mark “x ” (if the mark is not set, 0 is returned)

返回值是一个整数。这个函数功能时返回一个行号。如果你后面的参数expr是"."的话，则返回当前光标所在的位置。如果extr是"$"则返回当前缓冲区最后一行的行号。如果extr的值是一个标签名,则返回你对应的标签所在的行号。

例如：call line(".") 这条语句执行的结果是得到当前光标所在的行号。

 

### setline ({lnum}, {text} )

Set line {lnum} of the current buffer to {text}.If this succeeds, 0 is returned. If this fails (most likely lnumis invalid) 1 is returned.

When {lnum} is just below the last line the {text} will be added as a new line。

这个函数就是将第lnum行的内容替换成text中的内容。如果这个lunm行是最后一行的下面一行，那么将新建一行，然后将text的内容存放到这一行。如果不是最后一行的下一行，则要满足的条件是行号为lnum的行必须是存在的。

例如：call setline(1, "/*************************************************************************")

这句话就是文件的开头添加上面的一行，主要是用于C/CPP文件注释的。

### getline(({lnum},{end})

Without the {end},the result is a String, which is  line {lnum} from the current buffer.

When {end} is given the result is a List where each item is a line from the current buffer in the range {lnum} to {end}, including line {end}.

返回值是一个字符串。当end参数存在的时候，函数返回行号为lnum的内容，否则函数将返回行lnum到行end的所有内容（包括第end行）。

例如：

let  lines=getline(2,5)
call append(6,lines)

上面两句话表示取得2-5行的内容，然后从第六行的下一行开始添加，保持原来的格式不变。

### append(lnum, string)

Append the text string after line lnum in the current buffer. lnum can be 
zero, to insert a line before the first one. Returns 1 for failure (lnum out of 
range) or 0 for success.

这个函数就是将string这个字符串，插入到行号为lnum的下一行。成功则返回0，否则返回1。

### expand(expr ,[ , flag])

Expand the file wildcards in expr . The result is a String .

When the result of expr starts with% , # or < , the expansion is done like for the cmdline- special variables with their associated modifiers. There cannot be a white space between the variables and the following modifier. When the current or alternate file name is not defined, % or # use an empty string. Using %:p in a buffer with no name results in the current directory, with a “/ ”added.

When {expr} starts with '%', '#' or '<', the expansion is done
    like for the |cmdline-special| variables with their associated
    modifiers.  Here is a short overview:
```bash
        %        current file name
        #        alternate file name
        #n        alternate file name n
        <cfile>        file name under the cursor
        <afile>        autocmd file name
        <abuf>        autocmd buffer number (as a String!)
        <amatch>    autocmd matched name
        <sfile>        sourced script file name
        <cword>        word under the cursor
        <cWORD>        WORD under the cursor
        <client>    the {clientid} of the last received
                message |server2client()|
    Modifiers:
        :p        expand to full path
        :h        head (last path component removed)
        :t        tail (last path component only)
        :r        root (one extension removed)
        :e        extension only
```  
函数的返回值是一个字符串。功能就是将参数expr这个通配符进行扩展。各个通配符的含义上面列出来了。

例子：

例1.call append(2, "    File Name: ".expand("%"))

这句话执行过后，将在文件的第三行写入这句话File Name: 文件名，这边%表示当前文件的名称，通过函数expand（"%"）将其还原成了文件名字符串。

例2.

let sourcefilepath=expand("%:p")

这个句话表示获取到当前文件的完全路径（绝对路径）。

参考文献：

【1】vim的官方帮助文档 （：help ）
