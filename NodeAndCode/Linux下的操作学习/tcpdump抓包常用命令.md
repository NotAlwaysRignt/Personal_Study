先用ifconfig查看网卡接口名称,一般为 eth1, -i 可以指定接口名称
一般我们还需要指定特定的端口,每个服务都会占用特定的端口,所以只要指定了网卡接口 和 端口,就可以监听特定服务的包了
```bash
sudo tcpdump -i eth1 'port 65531' -X 
```
-X 告诉tcpdump命令，需要把协议头和包内容都原原本本的显示出来（tcpdump会以16进制和ASCII的形式显示），这在进行协议分析时是绝对的利器。

### BPF 过滤
BPF 的语法很简单,只要记住`指标 (空格) 值` 这个规则(当然也不全是,比如 ip[0] = 0xac 这样的),要哪些指标可以网上查,如`port 22`,`dst xxx.xxx.xxx.xxx`,要指定多个属性,则可以用与或非等运算指令连接起来
##### 抓指定协议
tcpdump 可以过滤指定内容的包, 用 tcpdump -X 打印到屏幕上出现的内容包括了IP头,TCP 头,TCP body
```bash
19:03:27.635425 IP XXX.XXX.XXX.XXX.37379 > XXX.XXX.XXX.XXX.65510: Flags [P.], seq 2745148990:2745149222, ack 975101530, win 15, options [nop,nop,TS val 3154198563 ecr 3394990102], length 232
        0x0000:  4564 011c e636 4000 3b06 c45b 0aee 02e3  Ed...6@.;..[....
        0x0010:  0a31 7be4 9203 ffe6 a39f a63e 3a1e de5a  .1{........>:..Z
        0x0020:  8018 000f 726e 0000 0101 080a bc01 4023  ....rn........@#
        0x0030:  ca5b 7016 2500 0000 e801 0000 0000 0000  .[p.&...........
        0x0040:  0000 0000 0a0c 11fa 112c 3c4c 5c6c 7c8c  .........,<L\l|.
        0x0050:  0b1a 0c1c 2c3c 4c56 0066 0076 0086 009c  ....,<LV.f.v....
        0x0060:  a600 b600 ccdc ecfc 0ffa 1006 0016 002c  ...............,
        0x0070:  3c4c 5600 6c7c 8c96 00a6 00b6 00c6 00d6  <LV.l|..........
        0x0080:  00e6 00fa 0f0c 1c26 003c 4a0c 1600 2600  .......&.<J...&.
        0x0090:  0b0b fc10 f611 00fc 12f6 1300 f614 00f6  ................
        0x00a0:  1500 fa16 0c14 0000 0000 2400 0000 0035  ..........$....5
        0x00b0:  0000 0000 0000 0000 0bf6 1700 f618 00fc  ................
        0x00c0:  19fc 1afc 1b0b f611 00fa 1206 0016 002c  ...............,
        0x00d0:  3600 4c56 0066 0076 0086 0096 00a6 000b  6.LV.f.v........
        0x00e0:  fc13 fc14 f915 0cf6 1600 f617 000b 290c  ..............).
        0x00f0:  3609 0001 1001 2c30 0a4c 5c49 0c5a 0a0c  6.....,0.L\I.Z..
        0x0100:  1c26 0036 0046 0056 0066 0076 0088 0c98  .&.6.F.V.f.v....
        0x0110:  0ca8 0c0b 1a09 0c16 000b 0b28            ...........(
```
如下图,使用伯克利过滤语法时,索引从0开始,即第一个数据ip[0] == 0x45 ,tcp头部位于0x14处, 即0x9203,这个是源地址端口,转换成十进制即37379, ip[0x34]处开始即我们需要的内容,假设协议中 0x25 是固定的头部,根据上面的规律,我们可以写如下的抓包规则
```bash
sudo tcpdump -i eth1 'tcp port 65510 and dst XXX.XXX.XXX.XXX and  ip[0x34] = 0x25' -X
```
单引号内即伯克利过滤语法

当然,上面用硬编码的方式指定了起始位置,这并不合理,因为tcp首部或ip首部长度都会变动,一旦变动了,那么原来的规则就不适用了,因此我们需要更通用的方式

```bash
sudo tcpdump -i eth1 'tcp port 65510 and dst XXX.XXX.XXX.XXX and tcp[(tcp[12]&0xf0)>>2] = 0x25' -X
```
这里解释一下上面 tcp[(tcp[12]&0xf0)>>2] 的意思:
根据TCP协议(具体头部格式请查找相关资料),TCP第13个字节的前四位用于表示首部的长度,长度单位是字节,我们可以用 BPF 语法的 tcp[12] (索引从0开始) 获得 TCP 数据的第 13 个字节,但是首部长度只有 4 位,一字节有8位,因此我们要获取高4位要与上 0xf0,与运算完后找个数值是首部长度数值左移了两位的结果(比如首部长度为0x08,通过刚才的运算得到的是 0x0800),我们要获取首部长度应该令其右移2位

综上 `tcp[(tcp[12]&0xf0)>>2]`取到的就是TCP body的第一个字节,已知JCE 内容第一个字节是固定的0x25,因此可以取到上面的数值

**对于 -i eth1,如果我们不知道网卡是哪个,可以用ifconfig 查,当然最简单的,用 -i any,任意网卡都抓下来**
