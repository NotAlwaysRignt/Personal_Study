动态规划的思考过程:
设定一个函数 func 可以找到该问题的最优解.

将该问题A 可视作 所有的(子问题a的最优解 加上 一步操作后)的结果中再取最优解. 
比如 A[n] = max(A[n-i]+i) i=0,1,2,..n;

找到A与子问题的关系,并用公式表示出来(列出表达式后,编程思路就会变得清晰很多),有时候变量是多个的,我们可以用多维数组来存储结果
比如以下关系:(不用管这个例子的物理意义,这里要强调的是,问题和子问题可能会涉及分类讨论(用if解决),还可能会涉及多个变量,比如下面有两个变量 i,j,它们都是动态变化且需要考虑的)

c[i][j]= 0                                    i=0或 j=0;
c[i][j]= c[i-1][j-1]+1                        i,j>0 且 xi = yj;
c[i][j]= max(c[i][j-1],c[i-1][j])             i,j>0且xi != yj



i,j作为子问题都是动态变化的值,即 0&lt;= i &lt;=n; 0&lt;= j &lt;=n;  
为了在写代码时思路有序,可以用
for i = 1 to n
　　for j = 1 to n
的嵌套形式有序遍历  

写代码:
思路1. 自顶向下,递归调用
思路2. 自底向上,使用for 循环,先从最最简单的子问题入手(我们可以知道其答案).再逐层往上构建答案,比如已知
比如 求 c[n],已知条件 c[n] =  c[n-1] + c[n-2]
直接求c[n]是求不了的, 我们可以先初始化,c[0]和 c[1],然后由 c[0]+ c[1] = c[2], c[1]+c[2] = c[3] 这样向上求解.

注意用一个临时的数组保存子问题的解,比如上面的c[1],c[2]并不是我们要求的结果,但它是c[n]求解过程中子问题的解,用临时空间保存子问题的解,下次需要用时判断一下是否已经求解,若已经求解可直接用,避免了重复的运算,大大提升效率
