首先明确一些概念

git底层命令:
我们常用的 git add, git commit实际上属于 git 的高层命令,也就是说,git 还提供了一些更加底层的命令,可以
控制 git 的一些文件操作, git add, git commit 实际上是对这些底层命令的封装结果,这里我们不介绍底层命令
我们只看看 git 的本质

快照的本质:
每次使用 git add, git commit, git会根据当前所有的文件做一个快照处理,其效果相当于给所有的文件做了一个备
份.当然事实上并不是那么简单,它还会进行 zlib 压缩和 delta 压缩处理,比如对 1G 的文件进行 add 和 commit,
获得一个备份文件,不妨称为 file1,并假设它经过 zlib 压缩处理后大小约为了800 MB, 然后我们稍作改动,又对这个
大约仍是1G的文件进行 add 和 commit,获得备份文件,不妨称为 file2, 其大小仍约为800 MB, file1 和 file2 
都很大,但他们的差异其实很小, git 会自动对它们做 delta 压缩,最后结果是,file1 的内容变成了 file1 和 
file2 中变化的部分, file1 大小可能只有几MB, 而 file2 则保存了完整的内容,大小仍约为 800 MB (因为大部分
情况下需要快速访问文件的最新版本)
综上所述,每次 add 和 commit ,git 在逻辑上都会给我们把当前所有的文件都拷贝一份进行压缩,但事实上git 也会
自动地对那些差异很小的备份文件进行再压缩,使某些备份文件只保留变化的部分



git对象:
git通过对象来组织文件,git 的各种对象(包括blob tree commit)都会以一个文件的形式存储在.git/objects/ 目
录下.git的本质就是一个键值数据库,所有对象都有一个40位的哈希值,通过40位的哈希值找到这些对象的内容,对象的内
容可以是其它的git对象,也可以是我们要管理的文件(被压缩后)
注意所有的git对象都存储在 git 内部的数据库中



blob对象:
blob对象即数据对象,每个文件(不包括目录,不过要注意的是目录的本质也是一个文件)最终都会被git copy 生成 
blob 对象,每个blob 对象有一个哈希值.同一个文件,修改前后分别提交,也会形成不同的blob. blob中压缩了文件的
内容,但通过blob 我们不知道文件名字(比如 test.txt 文件的内容为 'version 1',blob 压缩了'version 1'的
内容,但并没有记录 test.txt)

tree对象:
tree对象,我们要管理的文件中的每个目录文件都会对应一个 tree 对象,在 git 的数据库中, 一个 tree 可以指向多个 blob 对象或其它的 tree对象,比如 doc1 文件夹下有一个 test1.txt, test2.txt 和一个 doc2 目录文件,
那么这个 doc1 目录文件对应了git 数据库中的一个 tree 对象,  test1.txt ,test2.txt 文件对应 blob 文件
而 doc2 文件也对应一个 tree对象,其中 doc1 tree对象指向了 这两个blob对象 和 doc2 的tree对象
git在形成 tree 对象时,也要记录每个 blob 对象所对应文件的文件名, 因为 blob文件只是文件内容的压缩,blob
文件中并不记录文件名

commit 对象:
我们每次执行 git commit,就会获得一个提交对象,提交对象指向一个 tree 对象以及上一次的提交对象,因此我们每
次执行 commit,其最顶层一定是一个 tree 对象,另外因为我们指向了上一次的提交对象,因此我们也能够进行回滚操作
提交对象自身也有一个哈希值,提交对象不但包括了 tree 里的信息,还有添加的注释(也就是 git commit -m 后面的
注释),作者的名字和邮箱的信息.要获得提交对象,必须先响应的的 blob 和 tree 添加到暂存区中(就是 git add 添
加到的暂存区),然后才能获得提交对象 (对应底层命令是 git commit-tree )


git引用
git中分支的本质就是 git 引用,它们存储在 .git/refs 中,我们每次使用 git commit, 当前分支的引用就会
重新指向最新的提交对象. 那么我们如何知道我们当前操作的是 .git/refs 中的哪个引用文件?或者说我们如何知道当
前默认操作的是哪个分支?,这就是 HEAD引用的作用
HEAD 指向我们当前操作的分支,它是一个符号引用,存储在.git/HEAD 中,,也就是说,
HEAD 引用指向的不是提交对象,而是 .git/refs 内部的引用,而 .git/refs 指向的才是提交对象


明确了以上的概念:我们就可以知道了 git 内部的逻辑了
git中,不论是 tree 对象,commit 对象,blob 对象,还是各种引用,都对应了磁盘的一个文件,这些文件都有独一无二
的哈希值

每次 git add,和 git commit,我们仓库中所有的文件都会被进行一次拷贝,并经过 zlib 压缩,(git 还会进行
delta压缩处理,相当于记录了文件的差异,可以通过 git gc 显式执行,但逻辑上还是给整个文件做了一份拷贝压缩,即快照,)

仓库中的所有文件中,目录文件会被拷贝并保存为 tree 对象, 普通文件会被拷贝保存为 blob 对象
其中 tree 对象 和 blob 对象内部结构和我们管理文件的结构是一模一样的树状结构

当我们执行 git add 时,git 会将所有文件一一对应地拷贝出一份 tree 对象和 blob 对象,添加到暂存区中

当执行 git commit 时, git会创建一个最顶层的 tree 对象(可以理解根据我们最顶层的整个仓库的目录文件创建
的tree对象),作为暂存区的对象的最顶层,并创建一个 commit 对象,这个 commit 对象与最顶层的 tree 对象的不同
之处在于,它包含了注释 以及用户名,用户邮件信息,另外它还指向了上一个 commit 对象,这也是为什么 git 可以支持
回滚操作. 
当生成一个 commit 对象后, HEAD 所 指向的引用(.git/refs/中其中一个文件)也会去指向最新的 commit 对象

使用 git branch debug 创建一个名为 debug 的新分支时,实际就是在.git/refs/创建一个新的引用文件,这个引用
文件指向的是当前的 commit 对象, 当使用 git checkout debug 时,就是让 .git/HEAD 指向 debug 这个分支的
引用文件(引用文件的文件名是一个哈希值,不是debug)
